{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"POD-RBF","text":"<p>A Python package for building Reduced Order Models (ROMs) from high-dimensional data using Proper Orthogonal Decomposition combined with Radial Basis Function interpolation.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>JAX-based - Enables autodifferentiation for gradient optimization, sensitivity analysis, and inverse problems</li> <li>Shape parameter optimization - Automatic tuning of RBF shape parameters</li> <li>Memory-aware algorithms - Switches between eigenvalue decomposition and SVD based on memory requirements</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>pip install pod-rbf\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import pod_rbf\nimport jax.numpy as jnp\nimport numpy as np\n\n# Define training parameters\nRe = np.array([1, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])\n\n# Build snapshot matrix from CSV files\ntrain_snapshot = pod_rbf.build_snapshot_matrix(\"data/train/\")\n\n# Train the model\nresult = pod_rbf.train(train_snapshot, Re)\n\n# Inference on unseen parameter\nsol = pod_rbf.inference_single(result.state, jnp.array(450.0))\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>User Guide - Detailed usage instructions</li> <li>API Reference - Complete API documentation</li> <li>Examples - Jupyter notebook examples</li> </ul>"},{"location":"#references","title":"References","text":"<p>This implementation is based on the following papers:</p> <ol> <li>Solving inverse heat conduction problems using trained POD-RBF network inverse method - Ostrowski, Bialecki, Kassab (2008)</li> <li>RBF-trained POD-accelerated CFD analysis of wind loads on PV systems - Huayamave et al. (2017)</li> <li>Real-Time Thermomechanical Modeling of PV Cell Fabrication via a POD-Trained RBF Interpolation Network - Das et al. (2020)</li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>Explore these example notebooks to see POD-RBF in action:</p>"},{"location":"examples/#lid-driven-cavity","title":"Lid-Driven Cavity","text":"<p>A complete walkthrough using CFD data from a 2D lid-driven cavity simulation at various Reynolds numbers.</p> <p>:octicons-mark-github-16: View on GitHub{ .md-button }</p> <p>What you'll learn:</p> <ul> <li>Building a snapshot matrix from CSV files</li> <li>Training a single-parameter model</li> <li>Visualizing predictions vs. ground truth</li> </ul>"},{"location":"examples/#multi-parameter-example","title":"Multi-Parameter Example","text":"<p>Training a model with two input parameters.</p> <p>:octicons-mark-github-16: View on GitHub{ .md-button }</p> <p>What you'll learn:</p> <ul> <li>Setting up multi-parameter training data</li> <li>Inference with multiple parameters</li> <li>Parameter space exploration</li> </ul>"},{"location":"examples/#heat-conduction","title":"Heat Conduction","text":"<p>A simple heat conduction problem on a unit square.</p> <p>:octicons-mark-github-16: View on GitHub{ .md-button }</p> <p>What you'll learn:</p> <ul> <li>Basic POD-RBF workflow</li> <li>Working with thermal simulation data</li> </ul>"},{"location":"examples/#shape-parameter-optimization","title":"Shape Parameter Optimization","text":"<p>Exploring RBF shape parameter selection.</p> <p>:octicons-mark-github-16: View on GitHub{ .md-button }</p> <p>What you'll learn:</p> <ul> <li>How shape parameters affect interpolation</li> <li>Automatic vs. manual shape parameter selection</li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Clone the repository and install the package:</p> <pre><code>git clone https://github.com/kylebeggs/POD-RBF.git\ncd POD-RBF\npip install -e .\n</code></pre> <p>Then open the Jupyter notebooks in the <code>examples/</code> directory:</p> <pre><code>jupyter notebook examples/\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install POD-RBF using pip:</p> <pre><code>pip install pod-rbf\n</code></pre> <p>Or using uv:</p> <pre><code>uv add pod-rbf\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>POD-RBF follows a simple three-step workflow:</p> <ol> <li>Build a snapshot matrix - Collect solution data at different parameter values</li> <li>Train the model - Compute POD basis and RBF interpolation weights</li> <li>Inference - Predict solutions at new parameter values</li> </ol>"},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<pre><code>import pod_rbf\nimport jax.numpy as jnp\nimport numpy as np\n\n# 1. Define training parameters\nparams = np.array([1, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])\n\n# 2. Build snapshot matrix from CSV files\n#    Each CSV file contains one solution snapshot\nsnapshot = pod_rbf.build_snapshot_matrix(\"path/to/data/\")\n\n# 3. Train the model\nresult = pod_rbf.train(snapshot, params)\n\n# 4. Predict at a new parameter value\nprediction = pod_rbf.inference_single(result.state, jnp.array(450.0))\n</code></pre>"},{"location":"getting-started/#understanding-the-snapshot-matrix","title":"Understanding the Snapshot Matrix","text":"<p>The snapshot matrix <code>X</code> has shape <code>(n_samples, n_snapshots)</code>:</p> <ul> <li>Each column is one solution snapshot at a specific parameter value</li> <li>Each row corresponds to a spatial location or degree of freedom</li> <li><code>n_samples</code> is the number of points in your solution (e.g., mesh nodes)</li> <li><code>n_snapshots</code> is the number of parameter values you trained on</li> </ul> <p>For example, if you solve a problem on a 400-node mesh at 10 different parameter values, your snapshot matrix is <code>(400, 10)</code>.</p> <p>Parameter Ordering</p> <p>The order of columns in the snapshot matrix must match the order of your parameter array. If column 5 contains the solution at Re=500, then <code>params[4]</code> must equal 500.</p>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Training Models - Learn about training configuration options</li> <li>Inference - Single-point and batch predictions</li> <li>Autodifferentiation - Use JAX for gradients and optimization</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-functions","title":"Core Functions","text":""},{"location":"api/#train","title":"train","text":""},{"location":"api/#pod_rbf.train","title":"<code>pod_rbf.train(snapshot, train_params, config=TrainConfig(), shape_factor=None)</code>","text":"<p>Train POD-RBF model.</p>"},{"location":"api/#pod_rbf.train--parameters","title":"Parameters","text":"<p>snapshot : Array     Solution snapshots, shape (n_samples, n_snapshots).     Each column is a snapshot at a different parameter value. train_params : Array     Parameter values, shape (n_snapshots,) or (n_params, n_snapshots). config : TrainConfig     Training configuration. shape_factor : float, optional     RBF shape parameter. If None, automatically optimized.</p>"},{"location":"api/#pod_rbf.train--returns","title":"Returns","text":"<p>TrainResult     Training result containing model state and diagnostics.</p>"},{"location":"api/#inference","title":"inference","text":""},{"location":"api/#pod_rbf.inference","title":"<code>pod_rbf.inference(state, inf_params)</code>","text":"<p>Inference trained model at multiple parameter points.</p>"},{"location":"api/#pod_rbf.inference--parameters","title":"Parameters","text":"<p>state : ModelState     Trained model state from train(). inf_params : Array     Inference parameters, shape (n_params, n_points) or (n_points,).</p>"},{"location":"api/#pod_rbf.inference--returns","title":"Returns","text":"<p>Array     Predicted solutions, shape (n_samples, n_points).</p>"},{"location":"api/#inference_single","title":"inference_single","text":""},{"location":"api/#pod_rbf.inference_single","title":"<code>pod_rbf.inference_single(state, inf_param)</code>","text":"<p>Inference trained model at a single parameter point.</p> <p>More convenient for gradient computation.</p>"},{"location":"api/#pod_rbf.inference_single--parameters","title":"Parameters","text":"<p>state : ModelState     Trained model state from train(). inf_param : Array     Single inference parameter, scalar or shape (n_params,).</p>"},{"location":"api/#pod_rbf.inference_single--returns","title":"Returns","text":"<p>Array     Predicted solution, shape (n_samples,).</p>"},{"location":"api/#io-functions","title":"I/O Functions","text":""},{"location":"api/#build_snapshot_matrix","title":"build_snapshot_matrix","text":""},{"location":"api/#pod_rbf.build_snapshot_matrix","title":"<code>pod_rbf.build_snapshot_matrix(dirpath, skiprows=1, usecols=0, verbose=True)</code>","text":"<p>Load snapshot matrix from CSV files in directory.</p> <p>Files are loaded in alphanumeric order. Ensure parameter array matches this ordering.</p>"},{"location":"api/#pod_rbf.build_snapshot_matrix--parameters","title":"Parameters","text":"<p>dirpath : str     Directory containing CSV files. skiprows : int     Number of header rows to skip in each file. usecols : int or tuple     Column(s) to read from each file. verbose : bool     Show progress bar.</p>"},{"location":"api/#pod_rbf.build_snapshot_matrix--returns","title":"Returns","text":"<p>np.ndarray     Snapshot matrix, shape (n_samples, n_snapshots).     Returns NumPy array - convert to JAX as needed.</p>"},{"location":"api/#save_model","title":"save_model","text":""},{"location":"api/#pod_rbf.save_model","title":"<code>pod_rbf.save_model(filename, state)</code>","text":"<p>Save model state to file.</p>"},{"location":"api/#pod_rbf.save_model--parameters","title":"Parameters","text":"<p>filename : str     Output filename. state : ModelState     Trained model state.</p>"},{"location":"api/#load_model","title":"load_model","text":""},{"location":"api/#pod_rbf.load_model","title":"<code>pod_rbf.load_model(filename)</code>","text":"<p>Load model state from file.</p>"},{"location":"api/#pod_rbf.load_model--parameters","title":"Parameters","text":"<p>filename : str     Input filename.</p>"},{"location":"api/#pod_rbf.load_model--returns","title":"Returns","text":"<p>ModelState     Loaded model state with JAX arrays.</p>"},{"location":"api/#types","title":"Types","text":""},{"location":"api/#trainconfig","title":"TrainConfig","text":""},{"location":"api/#pod_rbf.TrainConfig","title":"<code>pod_rbf.TrainConfig</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Immutable training configuration.</p>"},{"location":"api/#modelstate","title":"ModelState","text":""},{"location":"api/#pod_rbf.ModelState","title":"<code>pod_rbf.ModelState</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Immutable trained model state - a valid JAX pytree.</p>"},{"location":"api/#trainresult","title":"TrainResult","text":""},{"location":"api/#pod_rbf.TrainResult","title":"<code>pod_rbf.TrainResult</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result from training, includes diagnostics.</p>"},{"location":"user-guide/autodiff/","title":"Autodifferentiation","text":"<p>POD-RBF is built on JAX, enabling automatic differentiation through the inference functions. This is useful for optimization, sensitivity analysis, and inverse problems.</p>"},{"location":"user-guide/autodiff/#computing-gradients","title":"Computing Gradients","text":"<p>Use <code>jax.grad</code> to compute gradients with respect to parameters:</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport pod_rbf\n\n# Train model\nresult = pod_rbf.train(snapshot, params)\nstate = result.state\n\n# Define an objective function\ndef objective(param):\n    prediction = pod_rbf.inference_single(state, param)\n    return jnp.sum(prediction ** 2)\n\n# Compute gradient\ngrad_fn = jax.grad(objective)\ngradient = grad_fn(jnp.array(450.0))\n</code></pre>"},{"location":"user-guide/autodiff/#optimization-example","title":"Optimization Example","text":"<p>Find the parameter value that minimizes a cost function:</p> <pre><code>import jax\nimport jax.numpy as jnp\nfrom jax import grad\n\ndef cost_function(param, target):\n    prediction = pod_rbf.inference_single(state, param)\n    return jnp.mean((prediction - target) ** 2)\n\n# Gradient descent\nparam = jnp.array(500.0)  # Initial guess\nlearning_rate = 10.0\n\nfor i in range(100):\n    grad_val = grad(cost_function)(param, target_solution)\n    param = param - learning_rate * grad_val\n\nprint(f\"Optimal parameter: {param}\")\n</code></pre>"},{"location":"user-guide/autodiff/#inverse-problems","title":"Inverse Problems","text":"<p>For inverse problems where you want to find the parameter that produced an observed solution:</p> <pre><code>import jax\nimport jax.numpy as jnp\nfrom jax.scipy.optimize import minimize\n\ndef inverse_objective(param):\n    prediction = pod_rbf.inference_single(state, param)\n    return jnp.sum((prediction - observed_solution) ** 2)\n\n# Use BFGS optimization\nresult = minimize(\n    inverse_objective,\n    x0=jnp.array(500.0),\n    method=\"BFGS\",\n)\n\nrecovered_param = result.x\n</code></pre>"},{"location":"user-guide/autodiff/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>Compute how sensitive the solution is to parameter changes:</p> <pre><code>import jax\nimport jax.numpy as jnp\n\n# Jacobian: how each output point changes with the parameter\njacobian_fn = jax.jacobian(\n    lambda p: pod_rbf.inference_single(state, p)\n)\nsensitivity = jacobian_fn(jnp.array(450.0))\n\n# sensitivity shape: (n_samples,) for single parameter\n# Positive values indicate the solution increases with the parameter\n</code></pre>"},{"location":"user-guide/autodiff/#multi-parameter-gradients","title":"Multi-Parameter Gradients","text":"<p>For models with multiple parameters:</p> <pre><code>def objective(params):\n    # params: [Re, Ma]\n    prediction = pod_rbf.inference_single(state, params)\n    return jnp.sum(prediction ** 2)\n\n# Gradient with respect to all parameters\ngrad_fn = jax.grad(objective)\ngradients = grad_fn(jnp.array([450.0, 0.15]))\n# gradients shape: (2,) - one gradient per parameter\n</code></pre>"},{"location":"user-guide/autodiff/#jit-compilation","title":"JIT Compilation","text":"<p>For performance, JIT-compile your gradient functions:</p> <pre><code>@jax.jit\ndef compute_gradient(param):\n    return jax.grad(objective)(param)\n\n# First call compiles; subsequent calls are fast\ngradient = compute_gradient(jnp.array(450.0))\n</code></pre>"},{"location":"user-guide/autodiff/#higher-order-derivatives","title":"Higher-Order Derivatives","text":"<p>JAX supports higher-order derivatives:</p> <pre><code># Second derivative (Hessian for scalar output)\nhessian_fn = jax.hessian(objective)\nhessian = hessian_fn(jnp.array(450.0))\n</code></pre>"},{"location":"user-guide/inference/","title":"Inference","text":"<p>After training, use the model to predict solutions at new parameter values.</p>"},{"location":"user-guide/inference/#single-point-inference","title":"Single-Point Inference","text":"<p>For predicting at a single parameter value:</p> <pre><code>import pod_rbf\nimport jax.numpy as jnp\n\n# Train the model\nresult = pod_rbf.train(snapshot, params)\n\n# Predict at a new parameter\nprediction = pod_rbf.inference_single(result.state, jnp.array(450.0))\n</code></pre> <p>The output shape is <code>(n_samples,)</code> - the same as one column of your snapshot matrix.</p>"},{"location":"user-guide/inference/#batch-inference","title":"Batch Inference","text":"<p>For predicting at multiple parameter values simultaneously:</p> <pre><code># Predict at multiple parameters\nnew_params = jnp.array([350.0, 450.0, 550.0])\npredictions = pod_rbf.inference(result.state, new_params)\n</code></pre> <p>The output shape is <code>(n_samples, n_points)</code> where <code>n_points</code> is the number of parameter values.</p>"},{"location":"user-guide/inference/#multi-parameter-inference","title":"Multi-Parameter Inference","text":"<p>For models trained with multiple parameters:</p> <pre><code># Single point with 2 parameters\nparam = jnp.array([450.0, 0.15])  # [Re, Ma]\nprediction = pod_rbf.inference_single(result.state, param)\n\n# Batch with 2 parameters\nparams = jnp.array([\n    [350.0, 0.1],\n    [450.0, 0.15],\n    [550.0, 0.2],\n])\npredictions = pod_rbf.inference(result.state, params)\n</code></pre>"},{"location":"user-guide/inference/#using-a-saved-model","title":"Using a Saved Model","text":"<p>Load a previously saved model and use it for inference:</p> <pre><code>state = pod_rbf.load_model(\"model.pkl\")\nprediction = pod_rbf.inference_single(state, jnp.array(450.0))\n</code></pre>"},{"location":"user-guide/inference/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Use batch inference when predicting at multiple parameter values - it's more efficient than calling <code>inference_single</code> in a loop.</p> </li> <li> <p>JIT compilation - The inference functions are JAX-compatible and can be JIT-compiled for faster repeated calls:</p> </li> </ol> <pre><code>import jax\n\ninference_jit = jax.jit(lambda p: pod_rbf.inference_single(state, p))\nprediction = inference_jit(jnp.array(450.0))\n</code></pre> <ol> <li>GPU acceleration - If JAX is configured with GPU support, inference will automatically use the GPU.</li> </ol>"},{"location":"user-guide/io/","title":"Saving &amp; Loading","text":""},{"location":"user-guide/io/#loading-snapshot-data","title":"Loading Snapshot Data","text":""},{"location":"user-guide/io/#from-csv-files","title":"From CSV Files","text":"<p>Load snapshots from a directory of CSV files:</p> <pre><code>import pod_rbf\n\nsnapshot = pod_rbf.build_snapshot_matrix(\"path/to/data/\")\n</code></pre> <p>By default, this:</p> <ul> <li>Loads all CSV files from the directory in alphanumeric order</li> <li>Skips the first row (header)</li> <li>Uses the first column</li> </ul> <p>Customize with optional parameters:</p> <pre><code>snapshot = pod_rbf.build_snapshot_matrix(\n    \"path/to/data/\",\n    skiprows=1,      # Skip first N rows (default: 1 for header)\n    usecols=0,       # Column index to use (default: 0)\n    verbose=True,    # Show progress bar (default: True)\n)\n</code></pre>"},{"location":"user-guide/io/#from-numpy-arrays","title":"From NumPy Arrays","text":"<p>If your data is already in memory:</p> <pre><code>import numpy as np\n\n# Combine individual solutions into a snapshot matrix\n# Each column is one snapshot\nsnapshot = np.column_stack([sol1, sol2, sol3, sol4, sol5])\n</code></pre>"},{"location":"user-guide/io/#saving-models","title":"Saving Models","text":"<p>Save a trained model to disk:</p> <pre><code>import pod_rbf\n\nresult = pod_rbf.train(snapshot, params)\npod_rbf.save_model(\"model.pkl\", result.state)\n</code></pre> <p>The model is saved as a pickle file containing the <code>ModelState</code> NamedTuple.</p>"},{"location":"user-guide/io/#loading-models","title":"Loading Models","text":"<p>Load a previously saved model:</p> <pre><code>state = pod_rbf.load_model(\"model.pkl\")\n\n# Use for inference\nprediction = pod_rbf.inference_single(state, jnp.array(450.0))\n</code></pre>"},{"location":"user-guide/io/#model-state-contents","title":"Model State Contents","text":"<p>The saved <code>ModelState</code> contains everything needed for inference:</p> Field Description <code>basis</code> Truncated POD basis matrix <code>weights</code> RBF interpolation weights <code>shape_factor</code> Optimized RBF shape parameter <code>train_params</code> Training parameter values <code>params_range</code> Parameter ranges for normalization <code>truncated_energy</code> Energy retained after truncation <code>cumul_energy</code> Cumulative energy per mode <code>poly_coeffs</code> Polynomial coefficients (if used) <code>poly_degree</code> Polynomial degree used <code>kernel</code> Kernel type used <code>kernel_order</code> PHS order (for polyharmonic splines)"},{"location":"user-guide/io/#file-format-notes","title":"File Format Notes","text":"<ul> <li>Models are saved using Python's <code>pickle</code> module</li> <li>Files are portable across machines with the same Python/JAX versions</li> <li>File size depends on the number of modes and training points</li> </ul>"},{"location":"user-guide/training/","title":"Training Models","text":""},{"location":"user-guide/training/#building-the-snapshot-matrix","title":"Building the Snapshot Matrix","text":"<p>The snapshot matrix contains your training data. Each column is a solution snapshot at a specific parameter value.</p>"},{"location":"user-guide/training/#from-csv-files","title":"From CSV Files","text":"<p>If your snapshots are stored as individual CSV files in a directory:</p> <pre><code>import pod_rbf\n\nsnapshot = pod_rbf.build_snapshot_matrix(\"path/to/data/\")\n</code></pre> <p>Files are loaded in alphanumeric order. The function expects one value per row in each CSV file.</p> <p>File Organization</p> <p>Keep all training snapshots in a dedicated directory. Files are sorted alphanumerically, so use consistent naming like <code>snapshot_001.csv</code>, <code>snapshot_002.csv</code>, etc.</p>"},{"location":"user-guide/training/#from-arrays","title":"From Arrays","text":"<p>If you already have your data in memory:</p> <pre><code>import numpy as np\n\n# Shape: (n_samples, n_snapshots)\nsnapshot = np.column_stack([solution1, solution2, solution3, ...])\n</code></pre>"},{"location":"user-guide/training/#training","title":"Training","text":""},{"location":"user-guide/training/#basic-training","title":"Basic Training","text":"<pre><code>import pod_rbf\nimport numpy as np\n\nparams = np.array([100, 200, 300, 400, 500])\nresult = pod_rbf.train(snapshot, params)\n</code></pre> <p>The <code>result</code> object contains:</p> <ul> <li><code>result.state</code> - The trained model state (use this for inference)</li> <li><code>result.n_modes</code> - Number of POD modes retained</li> <li><code>result.used_eig_decomp</code> - Whether eigendecomposition was used (vs SVD)</li> </ul>"},{"location":"user-guide/training/#training-configuration","title":"Training Configuration","text":"<p>Customize training with <code>TrainConfig</code>:</p> <pre><code>from pod_rbf import TrainConfig\n\nconfig = TrainConfig(\n    energy_threshold=0.99,  # Keep modes until 99% energy retained\n    kernel=\"imq\",           # RBF kernel: 'imq', 'gaussian', 'polyharmonic_spline'\n    poly_degree=2,          # Polynomial augmentation: 0=none, 1=linear, 2=quadratic\n)\n\nresult = pod_rbf.train(snapshot, params, config)\n</code></pre>"},{"location":"user-guide/training/#configuration-options","title":"Configuration Options","text":"Parameter Default Description <code>energy_threshold</code> 0.99 POD truncation threshold (0-1) <code>kernel</code> <code>\"imq\"</code> RBF kernel type <code>poly_degree</code> 2 Polynomial augmentation degree <code>mem_limit_gb</code> 16.0 Memory limit for algorithm selection <code>cond_range</code> (1e11, 1e12) Target condition number range <code>max_bisection_iters</code> 50 Max iterations for shape optimization"},{"location":"user-guide/training/#kernel-options","title":"Kernel Options","text":"<p>POD-RBF supports three RBF kernels:</p> <ul> <li><code>imq</code> (Inverse Multi-Quadrics) - Default, good general-purpose choice</li> <li><code>gaussian</code> - Smoother interpolation, requires careful shape parameter tuning</li> <li><code>polyharmonic_spline</code> - No shape parameter needed, use with <code>kernel_order</code></li> </ul> <pre><code># Using polyharmonic splines (no shape parameter optimization)\nconfig = TrainConfig(kernel=\"polyharmonic_spline\", kernel_order=3)\nresult = pod_rbf.train(snapshot, params, config)\n</code></pre>"},{"location":"user-guide/training/#multi-parameter-training","title":"Multi-Parameter Training","text":"<p>For problems with multiple parameters:</p> <pre><code>import numpy as np\n\n# Parameters shape: (n_params, n_snapshots)\nparams = np.array([\n    [100, 200, 300, 400],  # Parameter 1 (e.g., Reynolds number)\n    [0.1, 0.1, 0.2, 0.2],  # Parameter 2 (e.g., Mach number)\n])\n\nresult = pod_rbf.train(snapshot, params)\n</code></pre> <p>See the 2-parameter example for a complete walkthrough.</p>"},{"location":"user-guide/training/#manual-shape-parameter","title":"Manual Shape Parameter","text":"<p>If you want to specify the RBF shape parameter instead of using automatic optimization:</p> <pre><code>result = pod_rbf.train(snapshot, params, shape_factor=0.5)\n</code></pre>"},{"location":"user-guide/training/#understanding-pod-truncation","title":"Understanding POD Truncation","text":"<p>POD extracts the dominant modes from your snapshot data. The <code>energy_threshold</code> controls how many modes are kept:</p> <ul> <li><code>0.99</code> (default) - Keep modes until 99% of total energy is captured</li> <li>Higher values retain more modes (more accurate, slower inference)</li> <li>Lower values retain fewer modes (faster inference, may lose accuracy)</li> </ul> <p>After training, check how much energy was retained:</p> <pre><code>print(f\"Modes retained: {result.n_modes}\")\nprint(f\"Energy retained: {result.state.truncated_energy:.4f}\")\n</code></pre>"}]}